= JavaScript、函式、非同步

== 運算相關

=== Ternary Operator

=== Nullish Coalescing Operator/Assignment

=== Falsy

=== Custom Error

== 變數與作用域

=== var/let/const 差異

=== Hoisting

=== Temporal Dead Zone, TDZ

== 函式

=== Immediately Invoked Function Expression, IIFE

=== 高階函式 Higher-Order Function

=== 閉包 Closure

=== this

=== Arrow Function

== 非同步

=== 同步/非同步差異

=== XMLHttpRequest/fetch

=== AJAX

=== Promise
一個異步操作的最终完成（或失敗）及其结果值 + 

在Promise出現之前，JavaScript中的異步操作主要通過回調函數來實現 +
但是回調函數的方式存在一些問題，比如回調地獄問題(亦可以稱為波動拳問題) +
Promise的出現解決了回調地獄問題，讓代碼更加清晰，更容易理解
[source,javascript]
----
// 回調地獄
callback(() => {
  console.log("Hello!");
  callback(() => {
    console.log("Hello!");
    callback(() => {
      console.log("Hello!");
      callback(() => {
        console.log("Hello!");
      }, 200);
    }, 200);
  }, 200);
}, 200);
----

Promise是一個構造函式，需要透過new來建立一個Promise實例 +
Promise會接收一個被稱為excutor的函式作為參數， +
[source,javascript]
----
new Promise((resolve, reject) => {
  console.log("executor 立即執行"); // executor 立即執行
});
----

這個excutor函式會立即執行，並且接收兩個參數，分別是resolve與reject +
resolve與reject是兩個函式，用來表示Promise的最終狀態，

* resolve用來表示Promise成功完成，並且返回結果值
* reject用來表示Promise失敗，並且返回錯誤原因

[source,javascript]
----
function requestData(url) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (url === "explainthis.io") {
        resolve("hello welcome to explain this");
      } else {
        reject("it is not explain this");
      }
    }, 3000);
  });
}

// 1. 請求成功
requestData("explainthis.io").then((res) => {
    console.log(res); //hello welcome to explain this
});

//2. 請求失敗
requestData("explainthis.com").catch((e) => {
    console.log(e); //it is not explain this
});
----

Promise的狀態只有三種，並一定處於這三種狀態其中一種：

* pending: 初始狀態，既不是成功，也不是失敗狀態
* fulfilled: 表示操作成功完成
* rejected: 表示操作失敗

=== async/await

=== try…​catch 與非同步
